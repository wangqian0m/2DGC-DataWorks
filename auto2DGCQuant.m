function auto2DGCQuant(~,~)    
% Octave-Compatible
% Dependencies:
% - ImportAgilentFID.m from chemplexity/chromatography (MIT License):
%   https://github.com/chemplexity/chromatography
% - Baseline.m from chemplexity/chromatography (MIT License):
%   https://github.com/chemplexity/chromatography
% - ExponentialGaussian.m from chemplexity/chromatography (MIT License):
%   https://github.com/chemplexity/chromatography
% - FastPeakFind.m from adinatan/fastpeakfind (MIT License):
%   https://github.com/adinatan/fastpeakfind
% - xml2struct.m from Wouter Falkena (MIT License):
%   Wouter Falkena (2025). xml2struct (https://www.mathworks.com/matlabcentral/fileexchange/28518-xml2struct), MATLAB Central File Exchange. 
% auto2DGCQuant v1.0 - Automated GC×GC Quantification Tool
% Generated by Deepseek R1 Assistant
% License: MIT License

%% PARAMETER DECLARATION
baselineCorrection = true;   % Enable baseline correction
blankTime = 0.5;             % Solvent delay time (minutes)
modulationPeriod = 6.5;      % Modulation period (seconds)
signalRange = [3, 1000];     % Fixed color scale range [min, max]
RtCal_set = true;             % Retention time correction switch (true or false)
%% DATA IMPORT
try
    data = ImportAgilentFID(); % Third-party data import
    % Octave requires explicit field validation
    if exist('OCTAVE_VERSION', 'builtin')
        validateFields(data, {'Signal', 'Time', 'Slope'});
    end
catch ME
    error('Data import failed: %s\nEnsure ImportAgilentFID.m is in path', ME.message);
end

%% SIGNAL PREPROCESSING (Preserved original color handling)
if prctile(data.Signal, 1) > 10000 % Handle legacy data formats
    dataSignal = data.Signal * data.Slope;
else
    dataSignal = data.Signal;
end

%% BASELINE CORRECTION (Original algorithm preserved)
if baselineCorrection
    try
        dataBaseline = Baseline(dataSignal); 
        processedSignal = dataSignal - dataBaseline;
    catch
        warning('Baseline correction failed, using raw signal');
        processedSignal = dataSignal;
    end
else
    processedSignal = dataSignal;
end

%% DATA RESHAPING (Original matrix handling)
samplingRate = round(length(data.Time)/(60*data.Time(end)));
totalTime = round(data.Time(end));
samplesPerModulation = modulationPeriod * samplingRate;

trimStart = min(3000, numel(processedSignal));
trimmedSignal = processedSignal(trimStart:end);
validSamples = floor(numel(trimmedSignal)/samplesPerModulation) * samplesPerModulation;
alignedSignal = trimmedSignal(1:validSamples);

if isempty(alignedSignal)
    error('Processed signal is empty after alignment');
end
C = reshape(alignedSignal, samplesPerModulation, []);

%% INTERPOLATION (Original method preserved)
try
    C1 = interp2(single(C), 2); % Memory optimization
catch
    C1 = interp2(double(C), 2); % Octave fallback
end
%% VISUALIZATION SETUP (Full color implementation)
figure1 = figure('PaperPosition',[0.3 3.0 29.0 16.0],...
                'PaperSize',[29.68 20.98],...
                'Color','w',...
                'Name','2DGC Analysis');

if exist('OCTAVE_VERSION', 'builtin')
    graphics_toolkit('qt');
    set(figure1, 'Visible', 'off');
end

axes1 = axes('Parent',figure1,...
            'LineWidth',1.5,...
            'Layer','top',...
            'CLim',signalRange);

%% PLOT GENERATION (Original color mapping)
imagesc(C1, 'Parent', axes1);
applyColormap(axes1);
setAxisLabels(axes1);
configureColorbar(axes1, signalRange);
calibrateAxes(axes1, totalTime, samplingRate, modulationPeriod, blankTime);

%% HELPER FUNCTIONS ------------------------------------------------------
function validateFields(data, requiredFields)
    % Field validation for Octave
    missing = cellfun(@(f) ~isfield(data,f), requiredFields);
    if any(missing)
        error('Missing fields: %s', strjoin(requiredFields(missing), ', '));
    end
end

function applyColormap(ax)
    % Custom colormap application
    cmap = legacyColormap();
    colormap(ax, cmap);
end

function cmap = legacyColormap()
    % Full original color matrix preserved
        cmap = [1.000000000,1.000000000,1.000000000;
            0.971764706,0.971764706,1.000000000;
            0.943529412,0.943529412,1.000000000;
            0.915294118,0.915294118,1.000000000;
            0.887058824,0.887058824,1.000000000;
            0.858823529,0.858823529,1.000000000;
            0.830588235,0.830588235,1.000000000;
            0.802352941,0.802352941,1.000000000;
            0.774117647,0.774117647,1.000000000;
            0.745882353,0.745882353,1.000000000;
            0.717647059,0.717647059,1.000000000;
            0.689411765,0.689411765,1.000000000;
            0.661176471,0.661176471,1.000000000;
            0.632941176,0.632941176,1.000000000;
            0.604705882,0.604705882,1.000000000;
            0.576470588,0.576470588,1.000000000;
            0.548235294,0.548235294,1.000000000;
            0.520000000,0.520000000,1.000000000;
            0.491764706,0.491764706,1.000000000;
            0.463529412,0.463529412,1.000000000;
            0.435294118,0.435294118,1.000000000;
            0.407058824,0.407058824,1.000000000;
            0.378823529,0.378823529,1.000000000;
            0.350588235,0.350588235,1.000000000;
            0.322352941,0.322352941,1.000000000;
            0.294117647,0.294117647,1.000000000;
            0.265882353,0.265882353,1.000000000;
            0.255294118,0.295294118,0.960000000;
            0.244705882,0.324705882,0.920000000;
            0.234117647,0.354117647,0.880000000;
            0.223529412,0.383529412,0.840000000;
            0.212941176,0.412941176,0.800000000;
            0.202352941,0.442352941,0.760000000;
            0.191764706,0.471764706,0.720000000;
            0.181176471,0.501176471,0.680000000;
            0.170588235,0.530588235,0.640000000;
            0.160000000,0.560000000,0.600000000;
            0.149411765,0.589411765,0.560000000;
            0.138823529,0.618823529,0.520000000;
            0.128235294,0.648235294,0.480000000;
            0.117647059,0.677647059,0.440000000;
            0.107058824,0.707058824,0.400000000;
            0.096470588,0.736470588,0.360000000;
            0.085882353,0.765882353,0.320000000;
            0.075294118,0.795294118,0.280000000;
            0.064705882,0.824705882,0.240000000;
            0.054117647,0.854117647,0.200000000;
            0.043529412,0.883529412,0.160000000;
            0.032941176,0.912941176,0.120000000;
            0.022352941,0.942352941,0.080000000;
            0.011764706,0.971764706,0.040000000;
            0.001176471,1.000000000,0.000000000;
            0.039607843,1.000000000,0.000000000;
            0.078039216,1.000000000,0.000000000;
            0.116470588,1.000000000,0.000000000;
            0.154901961,1.000000000,0.000000000;
            0.193333333,1.000000000,0.000000000;
            0.231764706,1.000000000,0.000000000;
            0.270196078,1.000000000,0.000000000;
            0.308627451,1.000000000,0.000000000;
            0.347058824,1.000000000,0.000000000;
            0.385490196,1.000000000,0.000000000;
            0.423921569,1.000000000,0.000000000;
            0.462352941,1.000000000,0.000000000;
            0.500784314,1.000000000,0.000000000;
            0.539215686,1.000000000,0.000000000;
            0.577647059,1.000000000,0.000000000;
            0.616078431,1.000000000,0.000000000;
            0.654509804,1.000000000,0.000000000;
            0.692941176,1.000000000,0.000000000;
            0.731372549,1.000000000,0.000000000;
            0.769803922,1.000000000,0.000000000;
            0.808235294,1.000000000,0.000000000;
            0.846666667,1.000000000,0.000000000;
            0.885098039,1.000000000,0.000000000;
            0.923529412,1.000000000,0.000000000;
            0.961960784,1.000000000,0.000000000;
            1.000000000,1.000000000,0.000000000;
            1.000000000,0.994392157,0.000000000;
            1.000000000,0.988784314,0.000000000;
            1.000000000,0.983176471,0.000000000;
            1.000000000,0.977568627,0.000000000;
            1.000000000,0.971960784,0.000000000;
            1.000000000,0.966352941,0.000000000;
            1.000000000,0.960745098,0.000000000;
            1.000000000,0.955137255,0.000000000;
            1.000000000,0.949529412,0.000000000;
            1.000000000,0.943921569,0.000000000;
            1.000000000,0.938313725,0.000000000;
            1.000000000,0.932705882,0.000000000;
            1.000000000,0.927098039,0.000000000;
            1.000000000,0.921490196,0.000000000;
            1.000000000,0.915882353,0.000000000;
            1.000000000,0.910274510,0.000000000;
            1.000000000,0.904666667,0.000000000;
            1.000000000,0.899058824,0.000000000;
            1.000000000,0.893450980,0.000000000;
            1.000000000,0.887843137,0.000000000;
            1.000000000,0.882235294,0.000000000;
            1.000000000,0.876627451,0.000000000;
            1.000000000,0.871019608,0.000000000;
            1.000000000,0.865411765,0.000000000;
            1.000000000,0.859803922,0.000000000;
            1.000000000,0.854196078,0.000000000;
            1.000000000,0.848588235,0.000000000;
            1.000000000,0.842980392,0.000000000;
            1.000000000,0.837372549,0.000000000;
            1.000000000,0.831764706,0.000000000;
            1.000000000,0.826156863,0.000000000;
            1.000000000,0.820549020,0.000000000;
            1.000000000,0.814941176,0.000000000;
            1.000000000,0.809333333,0.000000000;
            1.000000000,0.803725490,0.000000000;
            1.000000000,0.798117647,0.000000000;
            1.000000000,0.792509804,0.000000000;
            1.000000000,0.786901961,0.000000000;
            1.000000000,0.781294118,0.000000000;
            1.000000000,0.775686275,0.000000000;
            1.000000000,0.770078431,0.000000000;
            1.000000000,0.764470588,0.000000000;
            1.000000000,0.758862745,0.000000000;
            1.000000000,0.753254902,0.000000000;
            1.000000000,0.747647059,0.000000000;
            1.000000000,0.742039216,0.000000000;
            1.000000000,0.736431373,0.000000000;
            1.000000000,0.730823529,0.000000000;
            1.000000000,0.725215686,0.000000000;
            1.000000000,0.719607843,0.000000000;
            1.000000000,0.714000000,0.000000000;
            1.000000000,0.708392157,0.000000000;
            1.000000000,0.702784314,0.000000000;
            1.000000000,0.697176471,0.000000000;
            1.000000000,0.691568627,0.000000000;
            1.000000000,0.685960784,0.000000000;
            1.000000000,0.680352941,0.000000000;
            1.000000000,0.674745098,0.000000000;
            1.000000000,0.669137255,0.000000000;
            1.000000000,0.663529412,0.000000000;
            1.000000000,0.657921569,0.000000000;
            1.000000000,0.652313725,0.000000000;
            1.000000000,0.646705882,0.000000000;
            1.000000000,0.641098039,0.000000000;
            1.000000000,0.635490196,0.000000000;
            1.000000000,0.629882353,0.000000000;
            1.000000000,0.624274510,0.000000000;
            1.000000000,0.618666667,0.000000000;
            1.000000000,0.613058824,0.000000000;
            1.000000000,0.607450980,0.000000000;
            1.000000000,0.601843137,0.000000000;
            1.000000000,0.596235294,0.000000000;
            1.000000000,0.590627451,0.000000000;
            1.000000000,0.585019608,0.000000000;
            1.000000000,0.579411765,0.000000000;
            1.000000000,0.573803922,0.000000000;
            1.000000000,0.568196078,0.000000000;
            1.000000000,0.562588235,0.000000000;
            1.000000000,0.556980392,0.000000000;
            1.000000000,0.551372549,0.000000000;
            1.000000000,0.545764706,0.000000000;
            1.000000000,0.540156863,0.000000000;
            1.000000000,0.534549020,0.000000000;
            1.000000000,0.528941176,0.000000000;
            1.000000000,0.523333333,0.000000000;
            1.000000000,0.517725490,0.000000000;
            1.000000000,0.512117647,0.000000000;
            1.000000000,0.506509804,0.000000000;
            1.000000000,0.500901961,0.000000000;
            1.000000000,0.495294118,0.000000000;
            1.000000000,0.489686275,0.000000000;
            1.000000000,0.484078431,0.000000000;
            1.000000000,0.478470588,0.000000000;
            1.000000000,0.472862745,0.000000000;
            1.000000000,0.467254902,0.000000000;
            1.000000000,0.461647059,0.000000000;
            1.000000000,0.456039216,0.000000000;
            1.000000000,0.450431373,0.000000000;
            1.000000000,0.444823529,0.000000000;
            1.000000000,0.439215686,0.000000000;
            1.000000000,0.433607843,0.000000000;
            1.000000000,0.428000000,0.000000000;
            1.000000000,0.422392157,0.000000000;
            1.000000000,0.416784314,0.000000000;
            1.000000000,0.411176471,0.000000000;
            1.000000000,0.405568627,0.000000000;
            1.000000000,0.399960784,0.000000000;
            1.000000000,0.394352941,0.000000000;
            1.000000000,0.388745098,0.000000000;
            1.000000000,0.383137255,0.000000000;
            1.000000000,0.377529412,0.000000000;
            1.000000000,0.371921569,0.000000000;
            1.000000000,0.366313725,0.000000000;
            1.000000000,0.360705882,0.000000000;
            1.000000000,0.355098039,0.000000000;
            1.000000000,0.349490196,0.000000000;
            1.000000000,0.343882353,0.000000000;
            1.000000000,0.338274510,0.000000000;
            1.000000000,0.332666667,0.000000000;
            1.000000000,0.327058824,0.000000000;
            1.000000000,0.321450980,0.000000000;
            1.000000000,0.315843137,0.000000000;
            1.000000000,0.310235294,0.000000000;
            1.000000000,0.304627451,0.000000000;
            1.000000000,0.299019608,0.000000000;
            1.000000000,0.293411765,0.000000000;
            1.000000000,0.287803922,0.000000000;
            1.000000000,0.282196078,0.000000000;
            1.000000000,0.276588235,0.000000000;
            1.000000000,0.270980392,0.000000000;
            1.000000000,0.265372549,0.000000000;
            1.000000000,0.259764706,0.000000000;
            1.000000000,0.254156863,0.000000000;
            1.000000000,0.248549020,0.000000000;
            1.000000000,0.242941176,0.000000000;
            1.000000000,0.237333333,0.000000000;
            1.000000000,0.231725490,0.000000000;
            1.000000000,0.226117647,0.000000000;
            1.000000000,0.220509804,0.000000000;
            1.000000000,0.214901961,0.000000000;
            1.000000000,0.209294118,0.000000000;
            1.000000000,0.203686275,0.000000000;
            1.000000000,0.198078431,0.000000000;
            1.000000000,0.192470588,0.000000000;
            1.000000000,0.186862745,0.000000000;
            1.000000000,0.181254902,0.000000000;
            1.000000000,0.175647059,0.000000000;
            1.000000000,0.170039216,0.000000000;
            1.000000000,0.164431373,0.000000000;
            1.000000000,0.158823529,0.000000000;
            1.000000000,0.153215686,0.000000000;
            1.000000000,0.147607843,0.000000000;
            1.000000000,0.142000000,0.000000000;
            1.000000000,0.136392157,0.000000000;
            1.000000000,0.130784314,0.000000000;
            1.000000000,0.125176471,0.000000000;
            1.000000000,0.119568627,0.000000000;
            1.000000000,0.113960784,0.000000000;
            1.000000000,0.108352941,0.000000000;
            1.000000000,0.102745098,0.000000000;
            1.000000000,0.097137255,0.000000000;
            1.000000000,0.091529412,0.000000000;
            1.000000000,0.085921569,0.000000000;
            1.000000000,0.080313725,0.000000000;
            1.000000000,0.074705882,0.000000000;
            1.000000000,0.069098039,0.000000000;
            1.000000000,0.063490196,0.000000000;
            1.000000000,0.057882353,0.000000000;
            1.000000000,0.052274510,0.000000000;
            1.000000000,0.046666667,0.000000000;
            1.000000000,0.041058824,0.000000000;
            1.000000000,0.035450980,0.000000000;
            1.000000000,0.029843137,0.000000000;
            1.000000000,0.024235294,0.000000000;
            1.000000000,0.018627451,0.000000000;
            1.000000000,0.013019608,0.000000000;
            1.000000000,0.007411765,0.000000000;
            1.000000000,0.000000000,0.000000000];
    
    % Platform-specific formatting
    if exist('OCTAVE_VERSION', 'builtin')
        cmap = uint8(cmap * 255);
    else
        cmap = min(max(cmap,0),1);
    end
end

function setAxisLabels(ax)
    % Axis labeling configuration
    xlabel(ax, 'Retention Time (min)', 'FontSize',14);
    ylabel(ax, 'Retention Time (s)', 'FontSize',14);
end

function configureColorbar(ax, range)
    % Colorbar configuration
    cbar = colorbar('peer', ax,...
                  'Location', 'eastoutside',...
                  'Box', 'on',...
                  'LineWidth', 1.5);
    set(ax, 'CLim', range);
    set(cbar, 'Limits', range);
    cbar.Label.String = 'Intensity (a.u.)';
    cbar.Label.FontSize = 12;
end

    function calibrateAxes(ax, totalTime, samplingRate, modulationPeriod, blankTime)
%% CALIBRATEAXES Original Axis Calibration Function
% Generate original tick labels and positions
t_m = modulationPeriod;       % Modulation period (seconds)
t_hz = samplingRate;          % Sampling rate (Hz)
y_labels = 1:t_m;             % Integer sequence from 1 to modulation period
y_positions = y_labels * 4 * t_hz - 3;  % Original position calculation formula

%% Dynamic range limitation
% Get actual data dimensions from image
Ymax = size(get(findobj(ax,'Type','image'),'CData'),1);
valid_idx = y_positions <= Ymax;  % Validate positions within data range

%% Axis configuration (preserve original parameters)
set(ax, 'YTick', y_positions(valid_idx),...
        'YTickLabel', y_labels(valid_idx),...
        'YDir','normal',...
        'Layer','top',...
        'LineWidth',1.5,...       % Original line width
        'TickLength',[0.005 0.025]);  % Original tick length

%% Maintain original X-axis calculation
% Generate X-axis ticks and positions
xTicks = 5:5:totalTime;  % 5-minute intervals
xPositions = ((xTicks - blankTime)*60/modulationPeriod)*4 - 3;  % Original conversion formula

% Apply X-axis settings
set(ax, 'XTick', xPositions,...
        'XTickLabel', xTicks);
    end
[fileFolder, ~, ~] = fileparts(data.filepath); 
if isempty(fileFolder)
    saveDir = pwd;  
else
    saveDir = fileFolder;
end
saveDir = fullfile(saveDir, '');  
if ~isfolder(saveDir)
    error('Directory not found: %s', saveDir);
end
outputPath = fullfile(saveDir, [data.SampleName, '-2D_Chromatogram.png']);
saveas(gcf, outputPath);


%% Peak Detection and Annotation
try
    % Perform peak detection using threshold=3
    p = FastPeakFind(C1, 3);  
    
    % Adjust coordinate system for platform differences
    [imgHeight, ~] = size(C1);
    if exist('OCTAVE_VERSION', 'builtin')
        % Flip Y-axis coordinates for Octave's image display system
        y_coords = imgHeight - p(2:2:end) + 1;  
    else
        % Maintain original coordinates for MATLAB
        y_coords = p(2:2:end);                   
    end
    
    % Plot peak markers on existing axes
    hold(axes1, 'on');
    plot(axes1, p(1:2:end), y_coords,...
        'black+',...               % Black plus marker
        'MarkerSize', 10,...       % Marker size adjustment
        'LineWidth', 0.5);         % Line width for visibility
    hold(axes1, 'off');
    
    % Save annotated plot while preserving original figure
    outputPath_peaks = fullfile(saveDir, [data.SampleName, '-2D_Chromatogram(PeakID-non-R.T.correction).png']);
    saveas(figure1, outputPath_peaks);
    close(figure1);                % Clean up figure after saving
    
catch ME
    % Error handling and resource cleanup
    warning('Peak marking failed: %s', ME.message);
    try
        close(figure1);            % Ensure figure closure on error
    catch
    end
end
%% 清理工作区
close all;
% Read CSV file (Compatible with Octave/MATLAB)
caldata = readtable('GC_Parameters.csv', 'TextType', 'string');
% Split data by parameter type (Auto-handle empty tables)
internalStd = caldata(caldata.ParameterType == "InternalStandard", :);
targetCompounds = caldata(caldata.ParameterType == "TargetCompound", :);
% Convert tables to structured arrays
params = struct(...
    'InternalStandard', table2struct(internalStd),...  % Now using struct format
    'TargetCompounds', table2struct(targetCompounds)...
);
% Extract reference coordinates (X=col3, Y=col4 from CSV)
std_X = params.InternalStandard(1).X;  % Direct struct field access
std_Y = params.InternalStandard(1).Y;
search_range = 30;  % Configurable threshold

% Reshape to [X positions; Y positions] matrix (2×N)
pos_matrix = reshape(p, 2, []);

% Create combined mask for coordinate filtering
valid_mask = (pos_matrix(1,:) >= std_X - search_range) & ...
             (pos_matrix(1,:) <= std_X + search_range) & ...
             (pos_matrix(2,:) >= std_Y - search_range) & ...
             (pos_matrix(2,:) <= std_Y + search_range);

% Preserve original output format: [X1 X2..., Y1 Y2...]
detected_coords = [pos_matrix(1,valid_mask), pos_matrix(2,valid_mask)];

% Fallback to reference coordinates if empty
if isempty(detected_coords)
    detected_coords = [std_X, std_Y]; 
end

% Retention time correction switch
switch RtCal_set
    case false
        offset = [0, 0];
        std_X=detected_coords(1);
        std_Y=detected_coords(2);
    case true
        % Calculate mean offset (handle multiple detections)
        avg_detected = mean(detected_coords, 1);  % [mean_X, mean_Y]
        offset = round([std_X - avg_detected(1), std_Y - avg_detected(2)]);
end

% Apply shift: [vertical_shift, horizontal_shift]
C2 = circshift(C1, [offset(2), offset(1)]); 
%% VISUALIZATION SETUP (Full color implementation)
figure1 = figure('PaperPosition',[0.3 3.0 29.0 16.0],...
                'PaperSize',[29.68 20.98],...
                'Color','w',...
                'Name','2DGC Analysis');

if exist('OCTAVE_VERSION', 'builtin')
    graphics_toolkit('qt');
    set(figure1, 'Visible', 'off');
end

axes1 = axes('Parent',figure1,...
            'LineWidth',1.5,...
            'Layer','top',...
            'CLim',signalRange);

%% PLOT GENERATION (Original color mapping)
imagesc(C2, 'Parent', axes1);
applyColormap(axes1);
setAxisLabels(axes1);
configureColorbar(axes1, signalRange);
calibrateAxes(axes1, totalTime, samplingRate, modulationPeriod, blankTime);
% Save plot
outputPath = fullfile(saveDir, [data.SampleName, '-2D_Chromatogram(R.T.correction).png']);
saveas(gcf, outputPath);
%% Peak Detection and Annotation 
try
    % Perform peak detection using threshold=3
    p1 = FastPeakFind(C2, 3);  
    p_1=reshape(p1,2,length(p1)/2);
    % Adjust coordinate system for platform differences
    [imgHeight, ~] = size(C1);
    if exist('OCTAVE_VERSION', 'builtin')
        % Flip Y-axis coordinates for Octave's image display system
        y_coords = imgHeight - p(2:2:end) + 1;  
    else
        % Maintain original coordinates for MATLAB
        y_coords = p1(2:2:end);                   
    end
    
    % Plot peak markers on existing axes
    hold(axes1, 'on');
    plot(axes1, p1(1:2:end), y_coords,...
        'black+',...               % Black plus marker
        'MarkerSize', 10,...       % Marker size adjustment
        'LineWidth', 0.5);         % Line width for visibility
    hold(axes1, 'off');
    
    % Save annotated plot while preserving original figure
    outputPath_peaks = fullfile(saveDir, [data.SampleName, '-2D_Chromatogram(PeakID-R.T.correction).png']);
    saveas(figure1, outputPath_peaks);
    close(figure1);                % Clean up figure after saving
    
catch ME
    % Error handling and resource cleanup
    warning('Peak marking failed: %s', ME.message);
    try
        close(figure1);            % Ensure figure closure on error
    catch
    end
end
%% Internal Standard Integration Module (Octave-Compatible)
scan_halfwidth = 5; % Symmetrical scan range parameter
% Preallocate memory for efficiency
peak_areas = zeros(2*scan_halfwidth, 1); 
left_wings = []; 
right_wings = [];

%% Step 1: Locate maximum response column
for scan_offset = 1:2*scan_halfwidth
    % Safely calculate column index (1-based)
    target_col = clamp_index(std_X + scan_halfwidth - scan_offset, size(C2,2));
    
    % Perform exponential Gaussian fit
    fit_result = ExponentialGaussian(1:size(C2,1), C2(:, target_col),...
                                    'center', std_Y); 
    peak_areas(scan_offset) = fit_result.area;
end

% Identify optimal integration column
[~, max_idx] = max(peak_areas);

%% Step 2: Left-side integration
current_col = clamp_index(std_X + scan_halfwidth - max_idx, size(C2,2));
fit_result = ExponentialGaussian(1:size(C2,1), C2(:, current_col),...
                                'center', std_Y);
total_area = fit_result.area;
area_buffer = [total_area-1, total_area]; % Initialize comparison buffer

wing_counter = 0;
while integration_continue(area_buffer, peak_areas)
    wing_counter = wing_counter + 1;
    current_col = clamp_index(std_X + scan_halfwidth - max_idx - wing_counter, size(C2,2));
    fit_result = ExponentialGaussian(1:size(C2,1), C2(:, current_col),...
                                    'center', std_Y);
    
    % Update integration state
    area_buffer = [fit_result.area, area_buffer(1)];
    total_area = total_area + fit_result.area;
    left_wings(end+1) = fit_result.area;
end
total_area = total_area - fit_result.area; % Rollback last iteration

%% Step 3: Right-side integration
fit_result = ExponentialGaussian(1:size(C2,1), C2(:, current_col),...
                                'center', std_Y);
area_buffer = [total_area-1, total_area];

wing_counter = 0;
while integration_continue(area_buffer, peak_areas)
    wing_counter = wing_counter + 1;
    current_col = clamp_index(std_X + scan_halfwidth - max_idx + wing_counter, size(C2,2));
    fit_result = ExponentialGaussian(1:size(C2,1), C2(:, current_col),...
                                    'center', std_Y);
    
    % Update integration state
    area_buffer = [fit_result.area, area_buffer(1)];
    total_area = total_area + fit_result.area;
    right_wings(end+1) = fit_result.area;
end
total_area = total_area - fit_result.area;

%% Final output
internal_area = total_area;

% Helper functions --------------------------------------------------------
function idx = clamp_index(val, max_col)
    % Ensure column index stays within [1, max_col]
    idx = max(1, min(round(val), max_col));
end

function flag = integration_continue(area_buffer, peak_areas)
    % Determine integration stopping condition
    % Original logic: (current < previous) OR (current > 80% of max peak)
    flag = (area_buffer(1) < area_buffer(2)) || ...
           (area_buffer(1) > 0.8*max(peak_areas));
end

%% Target Compound Verification Module
% Input: p_1 - 2×N matrix of detected peaks [X;Y]
%        params - GC parameters structure
% Output: confirm - Verification status array

%% Initialize parameters
confirm = zeros(1, length(params.TargetCompounds)); % Preallocate verification array
distance_threshold = 20; % Matching threshold (pixels)
y_weight = 0.2; % Retention time dimension weighting factor

%% Load target compounds from structure
% (Assume params already contains parsed target compounds)
% params structure format:
%   params.InternalStandard.X/Y
%   params.TargetCompound(n).Name/X/Y/Slope/Intercept

%% Compound verification process
for comp_idx = 1:length(params.TargetCompounds)
    % Extract current compound coordinates
    target_X = params.TargetCompounds(comp_idx).X;
    target_Y = params.TargetCompounds(comp_idx).Y;
    
    % Calculate weighted distance matrix
    dx = p_1(1,:) - target_X;
    dy = p_1(2,:) - target_Y;
    weighted_dist = sqrt(dx.^2 + y_weight*(dy.^2));
    
    % Find minimum distance match
    [min_dist, min_idx] = min(weighted_dist);
    
    % Verification decision
    if min_dist < distance_threshold
        confirm(comp_idx) = 1;
        % Optional: Update compound position to matched peak
        params.TargetCompounds(comp_idx).X = p_1(1,min_idx);
        params.TargetCompounds(comp_idx).Y = p_1(2,min_idx);
    else
        confirm(comp_idx) = 0;
    end
end

%% Generate confirmation report
confirmed_compounds = {params.TargetCompounds(confirm==1).Name};

%% GC Peak Integration Module (Octave-Compatible)
% Input: 
%   C2 - 2D chromatogram matrix 
%   params.TargetCompounds - Structure array with fields:
%       .X: 1D index 
%       .Y: 2D index 
% Output:
%   target_areas - Integrated peak areas [1×n vector]

%% Configuration Parameters
SCAN_HALFWIDTH = 5;       % Peak scanning window radius
RGE_FACTOR = 10;          % Dynamic window adjustment factor
AREA_THRESHOLD = 0.8;     % Continuation threshold (80% of max)
DELTA_THRESHOLD = 0.04;   % Relative change threshold (4%)

%% Pre-allocation
target_areas = zeros(1, numel(params.TargetCompounds));

%% Main Integration Loop
for comp_idx = 1:numel(params.TargetCompounds)
    % Extract compound coordinates
    comp = params.TargetCompounds(comp_idx);
    target_X = comp.X;
    target_Y = comp.Y;

    % Calculate dynamic search range
    [num_rows, num_cols] = size(C2);
    dyn_range = clamp_value(round(RGE_FACTOR*(target_Y-125)/375), 1, num_rows);
    
    %% Phase 1: Locate Optimal Column
    peak_areas = zeros(2*SCAN_HALFWIDTH, 1);
    for scan_offset = 1:2*SCAN_HALFWIDTH
        current_col = safe_column(target_X + SCAN_HALFWIDTH - scan_offset, num_cols);
        fit_result = fit_peak_profile(C2(:, current_col), target_Y);
        peak_areas(scan_offset) = fit_result.area;
    end
    [~, max_idx] = max(peak_areas);
    
    %% Phase 2: Left-side Integration
    [left_area, ~] = integrate_side(...
        C2, target_X, target_Y, max_idx, SCAN_HALFWIDTH,...
        dyn_range, peak_areas, AREA_THRESHOLD, DELTA_THRESHOLD,...
        'left', num_rows, num_cols...
    );
  
    %% Phase 3: Right-side Integration
    [right_area, ~] = integrate_side(...
        C2, target_X, target_Y, max_idx, SCAN_HALFWIDTH,...
        dyn_range, peak_areas, AREA_THRESHOLD, DELTA_THRESHOLD,...
        'right', num_rows, num_cols...
    );
  
    %% Total Area Calculation
    target_areas(comp_idx) = left_area + right_area-max(peak_areas);
end

%% Helper Functions ------------------------------------------------------
function result = fit_peak_profile(column_data, center, varargin)
    % Perform exponential Gaussian curve fitting
    % Input: column_data - Chromatogram column vector
    %        center - Initial peak center estimate
    % Output: result - Structure with .area field
    
    result = ExponentialGaussian(...
        1:numel(column_data),...
        column_data,...
        'center', center,...
        varargin{:}...
    );
end

function [integral, area_log] = integrate_side(C2, X, Y, idx, h, rge, area_max, thresh, delta, direction, max_row, max_col)
    % Unified integration engine for both directions
    % Inputs:
    %   direction - 'left' or 'right' integration direction
    %   max_row/max_col - Matrix dimension limits
    
    integral = 0;
    area_log = [];
    current_Y = Y;
    
    % Initialize from base column
    base_col = safe_column(X + h - idx, max_col);
    fit_result = fit_peak_profile(C2(:, base_col), Y);
    integral = fit_result.area;
    area_buffer = [integral-1, integral];
    
    step = 0;
    while continue_integration(area_buffer, area_max, thresh, delta)
        step = step + 1;
        
        % Calculate column offset
        col_offset = step * (2*strcmpi(direction, 'right') - 1);
        current_col = safe_column(X + h - idx + col_offset, max_col);
        
        % Dynamic window adjustment
        [win_start, win_end] = dynamic_window(current_Y, rge, max_row);
        [~, peak_loc] = max(C2(win_start:win_end, current_col));
        current_Y = win_start + peak_loc - 1;
        
        % Perform adaptive fitting
        fit_result = fit_peak_profile(...
            C2(:, current_col),...
            current_Y,...
            'width', win_end - win_start...
        );
        
        % Update integration state
        area_buffer = [fit_result.area, area_buffer(1)];
        integral = integral + fit_result.area;
        area_log(end+1) = fit_result.area;
    end
    
    % Rollback last iteration
    if ~isempty(area_log)
        integral = integral - area_log(end);
    end
end

function [start, end_] = dynamic_window(center, range, max_row)
    % Calculate adaptive search window
    start = max(1, center - range);
    end_ = min(max_row, center + range);
end

function flag = continue_integration(area, area_max, thresh, delta)
    % Determine integration continuation criteria
    current = area(1);
    previous = area(2);
    
    flag = (current < previous) || ...
          (current > thresh*max(area_max) && ...
          abs(current - previous)/current < delta);
end

function col = safe_column(val, max_col)
    % Generate safe column index within [1, max_col]
    col = max(1, min(round(val), max_col));
end

function val = clamp_value(val, min_val, max_val)
    % Constrain value within specified range
    val = max(min_val, min(round(val), max_val));
end
rsp = target_areas / internal_area;
% Add directory path

dataDir = strrep(saveDir, '/', '\');  % 
if ~strcmp(dataDir(end), '\')         % 
    dataDir = [dataDir '\'];
end
addpath(dataDir);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Get mass values from user input or XML file
if exist('SAMPLE.XML') == 0
    % Prompt dialog for mass values
    weight = inputdlg({'Enter internal standard mass:', 'Enter sample mass:'});
    weight = str2num(char(weight));
    m0 = weight(1);
    m1 = weight(2);
else
    % Read XML file structure
    weight0 = xml2struct('SAMPLE.XML');
    
    % Extract mass values from XML structure
    m0 = str2double(weight0.Sample.ISTDs.ISTD.Text);
    m1 = str2double(weight0.Sample.Amount.Text);
    
    % Validate mass values
    if (m0 <= 0 || m1 <= 0)
        % Re-prompt if invalid values found
        weight = inputdlg({'Enter internal standard mass:', 'Enter sample mass:'});
        weight = str2num(char(weight));
        m0 = weight(1);
        m1 = weight(2);
    end
end
rmpath(dataDir);
% Extract calibration parameters directly from table
calibration = [
    targetCompounds.Slope';    % 1st row: slopes
    targetCompounds.Intercept' % 2nd row: intercepts
];

% Stabilized calculation with epsilon protection
result = 100 * ((rsp - calibration(2,:)) ./ max(calibration(1,:), eps)) * (m0/m1);
% Generate output filenames (Octave-compatible)
output_file1 = fullfile(dataDir, [data.SampleName '-FullData.xlsx']);
output_file2 = fullfile(dataDir, [data.SampleName '-Report.xlsx']);

% Prepare data for Excel export
headers = {'Compound', 'Area', 'Percentage', 'Internal Standard'};
compound_names = targetCompounds.Name;

% Write comprehensive data
data_matrix = [
    headers;
    compound_names num2cell(target_areas') num2cell(result') ...
    repmat({internal_area}, length(result), 1)
];
xlswrite(output_file1, data_matrix);

% Process confirmed results
confirmed_result = num2cell(result .* confirm);
confirmed_result(cellfun(@(x) x == 0, confirmed_result)) = {'ND'};

% Write final report
report_matrix = [
    {'Compound', 'Percentage'};
    compound_names confirmed_result'
];
xlswrite(output_file2, report_matrix);
% Non-blocking completion message with auto-close
h = msgbox({'Export completed successfully!', ...
           ['Path: ' dataDir]}, ...
           'Operation Complete', ...
           'help', ...
           'non-modal');

end